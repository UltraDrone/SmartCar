C251 COMPILER V5.60.0,  zf_uart                                                            06/07/24  23:05:04  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_uart
OBJECT MODULE PLACED IN .\Out_File\zf_uart.obj
COMPILER INVOKED BY: G:\Keil_v5\C251\C251\BIN\C251.EXE ..\..\Libraries\seekfree_libraries\zf_uart.c XSMALL INTR2 WARNING
                    -LEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\se
                    -ekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;..\CODE) DEBUG PRINT(.\Out_File\zf_uart.lst) OBJECT(.\Out_File\zf_uart
                    -.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * COPYRIGHT NOTICE
    3           * Copyright (c) 2020,逐飞科技
    4           * All rights reserved.
    5           * 技术讨论QQ群：一群：179029047(已满)  二群：244861897(已满)  三群：824575535
    6           *
    7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
    8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
    9           *
   10           * @file                uart
   11           * @company                     成都逐飞科技有限公司
   12           * @author              逐飞科技(QQ790875685)
   13           * @version             查看doc内version文件 版本说明
   14           * @Software            MDK FOR C251 V5.60
   15           * @Target core         STC32G12K128
   16           * @Taobao              https://seekfree.taobao.com/
   17           * @date                2020-4-14
   18           ********************************************************************************************************
             -************/
   19          
   20          #include "zf_uart.h"
   21          #include "board.h"
   22          
   23          
   24          
   25          uint8 busy[5];                           //接收忙标志位
   26          
   27          
   28          
   29          
   30          //-------------------------------------------------------------------------------------------------------
             -------------
   31          //  @brief      串口初始化
   32          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
   33          //  @param      uart_rx_pin     串口接收引脚
   34          //  @param      uart_tx_pin     串口发送引脚
   35          //  @param      baud                    串口波特率
   36          //  @param      tim_n                   使用tim_n作为串口波特率发生器(TIM1-TIM4)
   37          //  @return     NULL
   38          //  Sample usage:               uart_init(UART_1, UART1_RX_P30, UART1_TX_P31, 115200, TIM_2);        //初
             -始化串口1 波特率115200 发送引脚使用P31 接收引脚使用P30 ,使用定时器2作为波特率发生器
   39          //  @note                       串口1使用 定时器1或者定时器2 作为波特率发生器。
   40          //                                                              串口2使用 定时器2                        作为波特率发生器。
   41          //                                                              串口3使用 定时器3或者定时器2 作为波特率发生器。
   42          //                                                              串口4使用 定时器4或者定时器2 作为波特率发生器。
   43          //                              STC32G仅有 定时器0-定时器4，这5个定时器。
   44          //                                                              编码器采集数据也需要定时器作为外部计数。
   45          //                                                              如果不同的串口，使用同一个定时器，串口的波特率以最后一个初始化为准
   46          //-------------------------------------------------------------------------------------------------------
             -------------
   47          void uart_init(UARTN_enum uart_n, UARTPIN_enum uart_rx_pin, UARTPIN_enum uart_tx_pin, uint32 baud, TIMN_e
             -num tim_n)
   48          {
   49   1          uint16 brt;
   50   1      
C251 COMPILER V5.60.0,  zf_uart                                                            06/07/24  23:05:04  PAGE 2   

   51   1          brt = (uint16)(65536 - (sys_clk / baud / 4));
   52   1      
   53   1      
   54   1          switch(uart_n)
   55   1          {
   56   2              case UART_1:
   57   2              {
   58   3                  if(TIM_1 == tim_n)
   59   3                  {
   60   4                      SCON |= 0x50;
   61   4                      TMOD |= 0x00;
   62   4                      TL1 = brt;
   63   4                      TH1 = brt >> 8;
   64   4                      AUXR |= 0x40;
   65   4                      TR1 = 1;
   66   4                      busy[1] = 0;
   67   4                  }
   68   3                  else if(TIM_2 == tim_n)
   69   3                  {
   70   4                      SCON |= 0x50;
   71   4                      T2L = brt;
   72   4                      T2H = brt >> 8;
   73   4                      AUXR |= 0x15;
   74   4                  }
   75   3      
   76   3                  P_SW1 &= ~(0x03 << 6);
   77   3      
   78   3                  if((UART1_RX_P30 == uart_rx_pin) && (UART1_TX_P31 == uart_tx_pin))
   79   3                  {
   80   4                      P_SW1 |= 0x00;
   81   4                  }
   82   3                  else if((UART1_RX_P36 == uart_rx_pin) && (UART1_TX_P37 == uart_tx_pin))
   83   3                  {
   84   4                      P_SW1 |= 0x40;
   85   4                  }
   86   3                  else if((UART1_RX_P16 == uart_rx_pin) && (UART1_TX_P17 == uart_tx_pin))
   87   3                  {
   88   4                      P_SW1 |= 0x80;
   89   4                  }
   90   3                  else if((UART1_RX_P43 == uart_rx_pin) && (UART1_TX_P44 == uart_tx_pin))
   91   3                  {
   92   4                      P_SW1 |= 0xc0;
   93   4                  }
   94   3      
   95   3                  busy[1] = 0;
   96   3                  ES = 1;
   97   3                  break;
   98   3              }
   99   2      
  100   2              case UART_2:
  101   2              {
  102   3                  if(TIM_2 == tim_n)
  103   3                  {
  104   4                      S2CON |= 0x50;
  105   4                      T2L = brt;
  106   4                      T2H = brt >> 8;
  107   4                      AUXR |= 0x14;
  108   4                  }
  109   3      
  110   3                  P_SW2 &= ~(0x01 << 0);
  111   3      
  112   3                  if((UART2_RX_P10 == uart_rx_pin) && (UART2_TX_P11 == uart_tx_pin))
  113   3                  {
  114   4                      P_SW2 |= 0x00;
  115   4                  }
  116   3                  else if((UART2_RX_P46 == uart_rx_pin) && (UART2_TX_P47 == uart_tx_pin))
C251 COMPILER V5.60.0,  zf_uart                                                            06/07/24  23:05:04  PAGE 3   

  117   3                  {
  118   4                      P_SW2 |= 0x01;
  119   4                  }
  120   3      
  121   3                  IE2 |= 0x01 << 0;   //允许串行口2中断
  122   3                  busy[2] = 0;
  123   3                  break;
  124   3              }
  125   2      
  126   2              case UART_3:
  127   2              {
  128   3                  if(TIM_2 == tim_n)
  129   3                  {
  130   4                      S3CON |= 0x10;
  131   4                      T2L = brt;
  132   4                      T2H = brt >> 8;
  133   4                      AUXR |= 0x14;
  134   4                  }
  135   3                  else if(TIM_3 == tim_n)
  136   3                  {
  137   4                      S3CON |= 0x50;
  138   4                      T3L = brt;
  139   4                      T3H = brt >> 8;
  140   4                      T4T3M |= 0x0a;
  141   4                  }
  142   3      
  143   3                  P_SW2 &= ~(0x01 << 1);
  144   3      
  145   3                  if((UART3_RX_P00 == uart_rx_pin) && (UART3_TX_P01 == uart_tx_pin))
  146   3                  {
  147   4                      P_SW2 |= 0x00;
  148   4                  }
  149   3                  else if((UART3_RX_P50 == uart_rx_pin) && (UART3_TX_P51 == uart_tx_pin))
  150   3                  {
  151   4                      P_SW2 |= 0x02;
  152   4                  }
  153   3      
  154   3                  IE2 |= 0x01 << 3;   //允许串行口3中断
  155   3                  busy[3] = 0;
  156   3                  break;
  157   3              }
  158   2      
  159   2              case UART_4:
  160   2              {
  161   3                  if(TIM_2 == tim_n)
  162   3                  {
  163   4                      S4CON |= 0x10;
  164   4                      T2L = brt;
  165   4                      T2H = brt >> 8;
  166   4                      AUXR |= 0x14;
  167   4                  }
  168   3                  else if(TIM_4 == tim_n)
  169   3                  {
  170   4                      S4CON |= 0x50;
  171   4                      T4L = brt;
  172   4                      T4H = brt >> 8;
  173   4                      T4T3M |= 0xa0;
  174   4                  }
  175   3      
  176   3                  P_SW2 &= ~(0x01 << 2);
  177   3      
  178   3                  if((UART4_RX_P02 == uart_rx_pin) && (UART4_TX_P03 == uart_tx_pin))
  179   3                  {
  180   4                      P_SW2 |= 0x00;
  181   4                  }
  182   3                  else if((UART4_RX_P52 == uart_rx_pin) && (UART4_TX_P53 == uart_tx_pin))
C251 COMPILER V5.60.0,  zf_uart                                                            06/07/24  23:05:04  PAGE 4   

  183   3                  {
  184   4                      P5M0 = 0x00;
  185   4                      P5M1 = 0x01 << 2; //P5.2 需要设置为高阻
  186   4                      P_SW2 |= 0x04;
  187   4                  }
  188   3      
  189   3                  IE2 |= 0x01 << 4;   //允许串行口4中断
  190   3                  busy[4] = 0;
  191   3                  break;
  192   3              }
  193   2      
  194   2          }
  195   1      
  196   1      }
  197          
  198          //-------------------------------------------------------------------------------------------------------
             -------------
  199          //  @brief      串口字节输出
  200          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
  201          //  @param      dat             需要发送的字节
  202          //  @return     void
  203          //  Sample usage:               uart_putchar(UART_1,0xA5);       // 串口1发送0xA5
  204          //-------------------------------------------------------------------------------------------------------
             -------------
  205          void uart_putchar(UARTN_enum uart_n, uint8 dat)
  206          {
  207   1          switch(uart_n)
  208   1          {
  209   2              case UART_1:
  210   2                  while (busy[1]);
  211   2      
  212   2                  busy[1] = 1;
  213   2                  SBUF = dat;
  214   2                  break;
  215   2      
  216   2              case UART_2:
  217   2                  while (busy[2]);
  218   2      
  219   2                  busy[2] = 1;
  220   2                  S2BUF = dat;
  221   2                  break;
  222   2      
  223   2              case UART_3:
  224   2                  while (busy[3]);
  225   2      
  226   2                  busy[3] = 1;
  227   2                  S3BUF = dat;
  228   2                  break;
  229   2      
  230   2              case UART_4:
  231   2                  while (busy[4]);
  232   2      
  233   2                  busy[4] = 1;
  234   2                  S4BUF = dat;
  235   2                  break;
  236   2          }
  237   1      }
  238          
  239          
  240          //-------------------------------------------------------------------------------------------------------
             -------------
  241          //  @brief      串口发送数组
  242          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
  243          //  @param      *buff           要发送的数组地址
  244          //  @param      len             发送长度
  245          //  @return     void
C251 COMPILER V5.60.0,  zf_uart                                                            06/07/24  23:05:04  PAGE 5   

  246          //  Sample usage:               uart_putbuff(UART_1,&a[0],5);
  247          //-------------------------------------------------------------------------------------------------------
             -------------
  248          void uart_putbuff(UARTN_enum uart_n, uint8 *p, uint16 len)
  249          {
  250   1          while(len--)
  251   1              uart_putchar(uart_n, *p++);
  252   1      }
  253          
  254          
  255          //-------------------------------------------------------------------------------------------------------
             -------------
  256          //  @brief      串口发送字符串
  257          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
  258          //  @param      *str            要发送的字符串地址
  259          //  @return     void
  260          //  Sample usage:               uart_putstr(UART_1,"i lvoe you");
  261          //-------------------------------------------------------------------------------------------------------
             -------------
  262          void uart_putstr(UARTN_enum uart_n, uint8 *str)
  263          {
  264   1          while(*str)
  265   1          {
  266   2              uart_putchar(uart_n, *str++);
  267   2          }
  268   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       907     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        36     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
