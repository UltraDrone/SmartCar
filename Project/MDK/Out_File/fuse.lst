C251 COMPILER V5.60.0,  fuse                                                               03/07/24  17:39:08  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE fuse
OBJECT MODULE PLACED IN .\Out_File\fuse.obj
COMPILER INVOKED BY: G:\Keil_v5\C251\C251\BIN\C251.EXE ..\CODE\fuse.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BRO
                    -WSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\U
                    -SER\inc;..\USER\src;..\CODE) DEBUG PRINT(.\Out_File\fuse.lst) OBJECT(.\Out_File\fuse.obj) 

stmt  level    source

    1          #include "fuse.h"
    2          #include "math.h"
    3          
    4          Body Flag;                  // ½á¹¹Ìå¶¨Òå¸÷Àà¹Ø¼ü±êÖ¾Î»
    5          int16 Turn_PWM = 0;                             // ×îÖÕ×ªÏòPWM
    6          float vtest = 0;
    7          //float vtest_t = 0;
    8          float RateLow = 0.7;
    9          float RateUp = 0.5;
   10          float tmptest = 0;
   11          int SideRate = 900, CornerRate = 1000, XieRate = 100;
   12          //PIDT testpid = {0}; 
   13          /*******************PIT¶¨Ê±ÖÐ¶Ï******************
   14          º¯Êý£ºvoid Fuse_result(void)
   15          ¹¦ÄÜ£ºËÙ¶È»·¡¢×ªÏò»·¿ØÖÆ
   16          ²ÎÊý£ºÎÞ
   17          ËµÃ÷£º
   18          ·µ»ØÖµ£ºÎÞ
   19           **********************************************/
   20          unsigned char int_OK = 0;                                                               // ³õÊ¼»¯³É¹¦±êÖ¾Î»
   21          unsigned char Flag_OpenLoop = 0;                                // Ä¬ÈÏ½øÐÐ±Õ»·¿ØÖÆ
   22          //int PID_Control_test(PIDT* pid, int flag)
   23          //{
   24          //    int inc;
   25          
   26          //    pid->ek = pid->SetValue - pid->ActualValue;
   27          
   28          //    inc = pid->KPS * (pid->ek - pid->ek_1) + pid->KIS * pid->ek
   29          //          + pid->KDS * (pid->ek - 2 * pid->ek_1 + pid->ek_2);
   30          
   31          //    pid->ek_2 = pid->ek_1; //äÕ´§•d´¬
   32          //    pid->ek_1 = pid->ek; //äÕ´§•d´¬
   33          //      
   34          //    pid->PIDout += inc;
   35          //         if(flag == 1)
   36          //    {
   37          //        if(pid->PIDout > pid->PIDmax)
   38          //            pid->PIDout = pid->PIDmax;
   39          //        if(pid->PIDout < pid->PIDmin)
   40          //            pid->PIDout = pid->PIDmin;
   41          //    }
   42          //    return pid->PIDout;
   43          //}
   44          void Fuse_result(void)
   45          {
   46   1          if(int_OK)
   47   1          {
   48   2              if(!Flag.start_go){
   49   3                  go_motor(-2000, -1000);     // ³ö½ç±£»¤
   50   3                              Flag.T_Inmost = 0;
   51   3                              Flag.T_Turn = 0;
   52   3                              Flag.T_Distance = 0;
   53   3                              Flag.T_IMU = 0;
   54   3                              Flag.T_Speed = 0;
   55   3                              Electromagnetism_Control();                  // µç¸Ð²É¼¯´¦Àí Ã°ÅÝÅÅÐò»¬¶¯ÂË²¨
   56   3                      }
   57   2              else
C251 COMPILER V5.60.0,  fuse                                                               03/07/24  17:39:08  PAGE 2   

   58   2              {
   59   3                  // 5ms¿ØÖÆ×îÄÚ»·:Çý¶¯ÂÖ×ÓÍùÇ°×ß
   60   3                  if(1 == Flag.T_Inmost)
   61   3                  {
   62   4                      Flag.T_Inmost = 0;
   63   4                      if(!Flag_Slope)                                                                                                         // Ö»Òª²»ÊÇÆÂµÀ
   64   4                                      {
   65   5                          Speed_PWM = OpenLoop_Speed;                                         // Ôò²»ÐèÒªÌí¼ÓËÙ¶È±Õ»·£¬Ö±½Ó½«µÍËÙÖµ¸³¸øÕ¼¿Õ±È
   66   5                                      }
   67   4                                      
   68   4      //                              Speed_PWM_tmp = PID_Realize(&SpeedPID, Speed_Pid, real_speed, ((ClsLoop_Speed) - abs(Turn_PWM) * (v
             -test) * RateLow) * 3.0 / 4) - Speed_PWM;               // ËÙ¶ÈÎ»ÖÃÊ½PID
   69   4      //                              if(Speed_PWM_tmp < 0){
   70   4      //                                      //Speed_PWM = range_protect(Speed_PWM + Speed_PWM_tmp, 500, ClsLoop_Speed + 500);
   71   4      //                                      Speed_PWM = range_protect(Speed_PWM + Speed_PWM_tmp, 1500, ((ClsLoop_Speed) - abs(Turn_PWM) * vtes
             -t * RateLow + 500) > 1500 ? ((ClsLoop_Speed) - abs(Turn_PWM) * vtest * RateLow + 500) : 1500);// ×¢ÒâÕý¸ººÅ
   72   4      //                              }else{
   73   4      //                                      //Speed_PWM = range_protect(Speed_PWM + Speed_PWM_tmp * RateUp, 500, ClsLoop_Speed + 500);
   74   4      //                                      Speed_PWM = range_protect(Speed_PWM + Speed_PWM_tmp * RateUp, 1500, ((ClsLoop_Speed) - abs(Turn_PW
             -M) * vtest * RateLow + 500) > 1500 ? ((ClsLoop_Speed) - abs(Turn_PWM) * vtest * RateLow + 500) : 1500);// ×¢ÒâÕý¸ººÅ
   75   4      //                              }
   76   4      //                              /*Speed_PWM = PID_Realize(&SpeedPID, Speed_Pid, real_speed, ClsLoop_Speed * 3.0 / 4);
   77   4      //                              Speed_PWM = range_protect(Speed_PWM, -ClsLoop_Speed - 500, ClsLoop_Speed + 500);*/
   78   4      //                // ·ñÔòÔò½«ËÙ¶È»·ÔËËã½á¹ûÍ¶ÈëÕ¼¿Õ±È
   79   4      //                All_PWM_left = Speed_PWM - (Turn_PWM) * (vtest/* * (real_speed / (ClsLoop_Speed * 3.0 /
             - 4) + 1)*/);
   80   4      //                All_PWM_right = Speed_PWM + (Turn_PWM) * (vtest/* * (real_speed / (ClsLoop_Speed * 3.0 
             -/ 4) + 1)*/);
   81   4                                      tmptest = (real_speed - 1500.0) / (ClsLoop_Speed - 1500.0) * (vtest - 0.6 * vtest) + 0.6 * vtest;
   82   4                                      All_PWM_left = PID_Realize(
   83   4                                              &SpeedPID, Speed_Pid, real_speed, 
   84   4                                              ((ClsLoop_Speed - (Turn_PWM) * (tmptest)) 
   85   4                                              - abs(Turn_PWM) * (tmptest) * RateLow) * 3.0 / 4
   86   4                                      );
   87   4                      All_PWM_right = PID_Realize(
   88   4                                              &SpeedPID, Speed_Pid, real_speed, 
   89   4                                              ((ClsLoop_Speed + (Turn_PWM) * (tmptest)) 
   90   4                                              - abs(Turn_PWM) * (tmptest) * RateLow) * 3.0 / 4
   91   4                                      );
   92   4                                      All_PWM_left = range_protect(All_PWM_left, -ClsLoop_Speed - 3000, ClsLoop_Speed + 3000);
   93   4                                      All_PWM_right = range_protect(All_PWM_right, -ClsLoop_Speed - 3000, ClsLoop_Speed + 3000);
   94   4                                      /*if(All_PWM_left < 0 && All_PWM_left > -1500){
   95   4                                              All_PWM_left = -1500;
   96   4                                      }else
   97   4                                      if(All_PWM_left > 0 && All_PWM_left < 1500){
   98   4                                              All_PWM_left = 1500;
   99   4                                      }
  100   4                                      if(All_PWM_right < 0 && All_PWM_right > -1500){
  101   4                                              All_PWM_right = -1500;
  102   4                                      }else
  103   4                                      if(All_PWM_right > 0 && All_PWM_right < 1500){
  104   4                                              All_PWM_right = 1500;
  105   4                                      }*/
  106   4                                      /*testpid.KPS = 10;
  107   4                                      testpid.KIS = 0.1;
  108   4                                      testpid.KDS = 0.1;
  109   4                                      testpid.PIDmax = 3000;
  110   4                                      testpid.PIDmin = -3000;
  111   4                                      testpid.SetValue = 1500 - adc_deviation * 50; // ´¬…‚
  112   4                                      testpid.ActualValue = left_speed;
  113   4                                      All_PWM_left = PID_Control_test(&testpid, 1);
  114   4                                      if(All_PWM_left == -3000 && adc_deviation < 0){
  115   4                                              All_PWM_left = 3000;
  116   4                                      }else
  117   4                                      if(All_PWM_left == 3000 && adc_deviation > 0){
  118   4                                              All_PWM_left = -3000;
C251 COMPILER V5.60.0,  fuse                                                               03/07/24  17:39:08  PAGE 3   

  119   4                                      }
  120   4                                      testpid.SetValue = 1500 + adc_deviation * 50;
  121   4                                      testpid.ActualValue = right_speed;
  122   4                                      All_PWM_right = PID_Control_test(&testpid, 1);
  123   4                                      if(All_PWM_right == -3000 && adc_deviation > 0){
  124   4                                              All_PWM_right = 3000;
  125   4                                      }else
  126   4                                      if(All_PWM_right == 3000 && adc_deviation < 0){
  127   4                                              All_PWM_right = -3000;
  128   4                                      }
  129   4                                      All_PWM_left = range_protect(All_PWM_left, -3000, 3000);
  130   4                                      All_PWM_right = range_protect(All_PWM_right, -3000, 3000);*/
  131   4                                      go_motor(All_PWM_left/*  * maxPWM*/, All_PWM_right/* * maxPWM*/);
  132   4                  }
  133   3      
  134   3                  // 10ms¿ØÖÆ£º¶æ»ú×ªÏò»·
  135   3                  if(1 == Flag.T_Turn && 0 == Flag_OpenLoop)
  136   3                  {
  137   4                      Flag.T_Turn = 0;
  138   4                      Electromagnetism_Control();                                             // µç´Å²É¼¯ËùÓÐ
  139   4                      adc_deviation = 0
  140   4                                              + Cha_BI_He_Sqrt(Left_Adc + Left_Corner_Adc * 1.5, Right_Adc + Right_Corner_Adc * 1.5, SideRate) 
  141   4                                              //+ Cha_BI_He_Sqrt(Left_Corner_Adc, Right_Corner_Adc, CornerRate) 
  142   4                                              + Cha_BI_He_Sqrt(Left_Xie_Adc, Right_Xie_Adc, XieRate); //   9£º 1
  143   4                      Turn_PWM = PlacePID_Control(&TurnPID, Turn_Pid[Turn_Suquence], adc_deviation, 0); //×ªÏò¶
             -¯Ì¬PID
  144   4                      Turn_PWM = abs(Turn_PWM);
  145   4                                      if(adc_deviation < 0)Turn_PWM *= -1;
  146   4                                      Turn_PWM = range_protect(Turn_PWM, -750, 750);
  147   4                                      Annulus_Analysis();                                                             // Ô²»·Ê¶±ð´¦Àí
  148   4                      //Steering_Control_Out(Turn_PWM);                               // ¶æ»ú×îÖÕÊä³ö£¨º¯ÊýÄÚ²¿ÒÑÏÞ·ù£©
  149   4                  }
  150   3      
  151   3                  // 30ms¿ØÖÆ£ºTOF±ÜÕÏ
  152   3                  if(1 == Flag.T_Distance)
  153   3                  {
  154   4                      Flag.T_Distance = 0;
  155   4      
  156   4                      if(!Flag_Tof_Finish)                                            // »¹Î´Íê³É¹ýÒ»´Î¼ì²â
  157   4                          Tof_Control();                                                              // ÕÏ°­Îï¼ì²â¿ØÖÆ
  158   4                  }
  159   3      
  160   3                  // 40ms¿ØÖÆ£ºÆÂµÀ¼ì²â(IMU660)
  161   3                  if(1 == Flag.T_IMU)
  162   3                  {
  163   4                      Flag.T_IMU = 0;
  164   4      //                                                              if(!Flag_Slope_Finish)
  165   4      //                                                                      IMU_Control();
  166   4                  }
  167   3      
  168   3                  // 50ms¿ØÖÆ£ºËÙ¶È±Õ»·¿ØÖÆ
  169   3                  if(1 == Flag.T_Speed)
  170   3                  {
  171   4                      Flag.T_Speed = 0;
  172   4                      //Speed_PWM = PID_Realize(&SpeedPID, Speed_Pid, real_speed, ClsLoop_Speed);             // ËÙ¶ÈÎ»ÖÃÊ
             -½PID
  173   4                      //Speed_PWM = range_protect(Speed_PWM, -0, 4000);                                                                                                       // ×¢ÒâÕý¸ººÅ
  174   4                  }
  175   3              }
  176   2          }
  177   1      }
  178          
  179          //ºËÐÄ¹Ø¼üµÄ±êÖ¾Î»½á¹¹Ìå³õÊ¼»¯
  180          void Flag_Init(void)
  181          {
  182   1          Flag.start_go = 0;
C251 COMPILER V5.60.0,  fuse                                                               03/07/24  17:39:08  PAGE 4   

  183   1          Flag.T_Inmost = 0;
  184   1          Flag.T_Turn = 0;
  185   1          Flag.T_Distance = 0;
  186   1          Flag.T_Speed = 0;
  187   1          Flag.T_IMU = 0;
  188   1          Flag.STOP = 0;                                                              // Í£³µ½áÊø
  189   1          Flag.OUT_Garage = 0;                                  // ³ö¿â±êÖ¾Î»
  190   1          Flag.Game = 0;
  191   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       914     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        35     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        66     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
