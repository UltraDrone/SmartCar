C251 COMPILER V5.60.0,  Direction                                                          06/07/24  23:55:37  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Direction
OBJECT MODULE PLACED IN .\Out_File\Direction.obj
COMPILER INVOKED BY: G:\Keil_v5\C251\C251\BIN\C251.EXE ..\CODE\Direction.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED
                    -) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE
                    -;..\USER\inc;..\USER\src;..\CODE) DEBUG PRINT(.\Out_File\Direction.lst) OBJECT(.\Out_File\Direction.obj) 

stmt  level    source

    1          #include "Direction.h"
    2          
    3          // ADC²É¼¯Öµ
    4          // Êı×éË÷Òı0~4·Ö±ğÎª
    5          // ×óµç¸Ğ×îÖÕÖµ  ÓÒµç¸Ğ×îÖÕÖµ  ×óĞ±µç¸Ğ×îÖÕÖµ  ÓÒĞ±µç¸Ğ×îÖÕÖµ  ÖĞ¼äµç¸Ğ×îÖÕÖµ
    6          uint16  adc_date[7];                                                             // ´¢´æµç¸Ğ²É¼¯Öµ Ô­Ê¼Öµ 5¸öµç¸Ğ
    7          
    8          // ADCÏŞ·ùÖµ
    9          uint16 adc_max[7] = {2000, 2000, 2200, 2200, 2200, 2200, 2000};      // ×î´óÖµ
   10          uint16 adc_min[7] = {0, 0, 100, 100, 100, 100, 100};                             // ×îĞ¡Öµ  (¸ø¶¨Ò»¸öĞèÒª)
   11          
   12          int16  adc_deviation;                                                                                                            // µç¸ĞÆ«²î
   13          int go_flag;
   14          // ADC²É¼¯×îÖÕÖµ
   15          int16 Left_Adc = 0, Right_Adc = 0, Mid_Adc = 0, Left_Xie_Adc = 0, Right_Xie_Adc = 0, Left_Corner_Adc = 0,
             - Right_Corner_Adc = 0;         //µç¸ĞÖµ
   16          
   17          /****************ADC³õÊ¼»¯**************************
   18          º¯  Êı£ºvoid ADC_Init(void)
   19          ¹¦  ÄÜ£ºADCÍ¨µÀÒı½Å³õÊ¼»¯
   20          ²Î  Êı£ºÎŞ
   21          Ëµ  Ã÷£ºADC_Init(ADC_P10,ADC_SYSclk_DIV_2);//³õÊ¼»¯P1.0ÎªADC¹¦ÄÜ,ADCÊ±ÖÓÆµÂÊ£ºSYSclk/2
   22          Òı  ½Å£º¼ûÍ·ÎÄ¼ş¶¨Òå
   23          ·µ»ØÖµ£ºÎŞ
   24          ***************************************************/
   25          void Analog_Digital_Converter_Init(void)
   26          {
   27   1          adc_init(Left_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   28   1          adc_init(LeftXie_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   29   1          adc_init(Mid_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   30   1          adc_init(RightXie_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   31   1          adc_init(Right_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   32   1              adc_init(LeftCorner_ADC_Pin,ADC_SYSclk_DIV_2);//³õÊ¼»¯ADC¹¦ÄÜ
   33   1              adc_init(RightCorner_ADC_Pin,ADC_SYSclk_DIV_2);//³õÊ¼»¯ADC¹¦ÄÜ
   34   1      }
   35          
   36          
   37          /****************µç¸Ğ²É¼¯**************************
   38          º¯  Êı£ºvoid ADC_MAX_Collect(void)
   39          ¹¦  ÄÜ£º
   40          ²Î  Êı£ºÎŞ
   41          Ëµ  Ã÷£ºµ÷ÓÃ¿âº¯Êı£¨×Ô¼ºĞ´µÄ£©    adc_mean_filter (ADC_P10, ADC_12BIT, 10)
   42          ·µ»ØÖµ£ºÎŞ
   43          **************************************************/
   44          void ADC_MAX_Collect(void)
   45          {
   46   1          int i, j;
   47   1      
   48   1          for(i = 600; i > 0; i--)
   49   1          {
   50   2              adc_date[0] = adc_mean_filter(Left_ADC_Pin, ADC_12BIT, 2);
   51   2              adc_date[1] = adc_mean_filter(Right_ADC_Pin, ADC_12BIT, 2);
   52   2              adc_date[2] = adc_mean_filter(LeftXie_ADC_Pin, ADC_12BIT, 2);
   53   2              adc_date[3] = adc_mean_filter(RightXie_ADC_Pin, ADC_12BIT, 2);
   54   2                      adc_date[4] = adc_mean_filter(LeftCorner_ADC_Pin, ADC_12BIT, 2);
   55   2              adc_date[5] = adc_mean_filter(RightCorner_ADC_Pin, ADC_12BIT, 2);
   56   2              adc_date[6] = adc_mean_filter(Mid_ADC_Pin, ADC_12BIT, 2);
C251 COMPILER V5.60.0,  Direction                                                          06/07/24  23:55:37  PAGE 2   

   57   2      
   58   2              for(j = 0; j < 7; j++)                                                                  // Èı¸öºáµç¸Ğ×÷ÏŞ·ù
   59   2              {
   60   3                  if(adc_date[j] >= adc_max[j])                                                       // ÉÏÏŞ·ù
   61   3                      adc_max[j] = adc_date[j];
   62   3      
   63   3                              if(adc_date[j] <= adc_min[j])                                                   // ÏÂÏŞ·ù
   64   3                                      adc_min[j] = adc_date[j];
   65   3                  delay_ms(2);//ÑÓÊ±²É¼¯
   66   3              }
   67   2          }
   68   1      }
   69          
   70          /****************µç¸Ğ²É¼¯**************************
   71          º¯  Êı£ºvoid AD_Date_Fitier()
   72          ¹¦  ÄÜ£º¶Ôµç¸Ğ²ÉÖµ½øĞĞÃ°ÅİÅÅĞò»¬¶¯ÂË²¨
   73          ²Î  Êı£ºÎŞ
   74          Ëµ  Ã÷£º12bit  4096   µ÷ÓÃ¿âº¯Êı£¨×Ô¼ºĞ´µÄ£©    adc_mean_filter(ADC_P10, ADC_12BIT, 10)
   75          ·µ»ØÖµ£ºÎŞ
   76          **************************************************/
   77          #define FILTER_N 5 //ÂË²¨Éî¶È
   78          
   79          void AD_Date_Fitier(void)
   80          {
   81   1          uint8 i;
   82   1          int16 filter_buf_L[FILTER_N];  //×óºáµç¸Ğ´¢´æÊı×é
   83   1          int16 filter_buf_LC[FILTER_N]; //×óĞ±µç¸Ğ´¢´æÊı×é
   84   1              int16 filter_buf_LX[FILTER_N]; //×óĞ±µç¸Ğ´¢´æÊı×é
   85   1          int16 filter_buf_M[FILTER_N];  //ÖĞºáµç¸Ğ´¢´æÊı×é
   86   1          int16 filter_buf_R[FILTER_N];  //ÓÒºáµç¸Ğ´¢´æÊı×é
   87   1          int16 filter_buf_RC[FILTER_N];  //ÓÒĞ±µç¸Ğ´¢´æÊı×é
   88   1              int16 filter_buf_RX[FILTER_N]; //×óĞ±µç¸Ğ´¢´æÊı×é
   89   1      
   90   1          //--------»¬¶¯ÂË²¨--------------
   91   1          for(i = 0; i < FILTER_N; i++)       //²ÉÖµ
   92   1          {
   93   2              filter_buf_L[i]  = adc_mean_filter(Left_ADC_Pin, ADC_12BIT, 10); //×óºá
   94   2              filter_buf_LX[i] = adc_mean_filter(LeftXie_ADC_Pin, ADC_12BIT, 5); //×óĞ±
   95   2                      filter_buf_LC[i] = adc_mean_filter(LeftCorner_ADC_Pin, ADC_12BIT, 5); //×óĞ±
   96   2              filter_buf_M[i]  = adc_mean_filter(Mid_ADC_Pin, ADC_12BIT, 5); //ÖĞ¼ä
   97   2              filter_buf_RC[i] = adc_mean_filter(RightCorner_ADC_Pin, ADC_12BIT, 5);  //ÓÒĞ±
   98   2                      filter_buf_RX[i] = adc_mean_filter(RightXie_ADC_Pin, ADC_12BIT, 5);//×óĞ±
   99   2              filter_buf_R[i]  = adc_mean_filter(Right_ADC_Pin, ADC_12BIT, 10); //ÓÒºá
  100   2          }
  101   1              //13 14 16 05 01 00
  102   1              //567321
  103   1      
  104   1          //--------Ã°ÅİÅÅĞòÈ¥¼«ÖµÇóÆ½¾ù---------
  105   1          adc_date[0] = I_Median_Average_Filter(filter_buf_L);  //×ó    3600
  106   1          adc_date[1] = I_Median_Average_Filter(filter_buf_R);  //ÓÒ    3600
  107   1          adc_date[2] = I_Median_Average_Filter(filter_buf_LX); //×óĞ±  3000
  108   1          adc_date[3] = I_Median_Average_Filter(filter_buf_RX); //ÓÒĞ±
  109   1              adc_date[4] = I_Median_Average_Filter(filter_buf_LC); //×óĞ±  3000
  110   1          adc_date[5] = I_Median_Average_Filter(filter_buf_RC); //ÓÒĞ±
  111   1          adc_date[6] = I_Median_Average_Filter(filter_buf_M);  //ÖĞ¼ä  4050
  112   1      
  113   1          Left_Adc = adc_date[0];                                                           //×óµç¸Ğ×îÖÕÖµ
  114   1          Right_Adc = adc_date[1];                                                  //ÓÒµç¸Ğ×îÖÕÖµ
  115   1          Left_Xie_Adc = adc_date[2];                                               //×óĞ±µç¸Ğ×îÖÕÖµ
  116   1          Right_Xie_Adc = adc_date[3];                                              //ÓÒĞ±µç¸Ğ×îÖÕÖµ
  117   1              Left_Corner_Adc = adc_date[4];
  118   1              Right_Corner_Adc = adc_date[5];
  119   1              Right_Corner_Adc = Right_Corner_Adc / 2;
  120   1          Mid_Adc = adc_date[6];                                                            //ÖĞ¼äµç¸Ğ×îÖÕÖµ
  121   1      }
  122          
C251 COMPILER V5.60.0,  Direction                                                          06/07/24  23:55:37  PAGE 3   

  123          void Protect_Anticollision(void)
  124          {
  125   1          if(Left_Adc < 100 && Right_Adc < 100){
  126   2              //Flag.start_go = 0;
  127   2                      go_flag = 0;
  128   2              }else
  129   1              if(Left_Adc > 150 || Right_Adc > 150){
  130   2                      //Flag.start_go = 1;
  131   2                      go_flag = 1;
  132   2              }
  133   1      }
  134          
  135          
  136          /*************************************
  137          º¯Êı£ºvoid Electromagnetism_Control(void)
  138          ¹¦ÄÜ£ºµç´Å¿ØÖÆ
  139          ²ÎÊı£ºÎŞ
  140          ËµÃ÷£º
  141          **************************************/
  142          void Electromagnetism_Control(void)
  143          {
  144   1          AD_Date_Fitier();                  // µç¸Ğ²É¼¯´¦Àí Ã°ÅİÅÅĞò»¬¶¯ÂË²¨
  145   1          
  146   1          /// normalize_date();               // ²É¼¯µç¸Ğ¹éÒ»»¯  0--100 ²»ÄÜÓÃ£¬Î´ÕÒµ½Ô­Òò£¬²»Òª¹éÒ»»¯À²
  147   1          Protect_Anticollision();                                            // ±£»¤
  148   1      }
  149          
  150          /*****************»·µº´¦Àí´úÂë***********************
  151          º¯Êı£ºvoid  annulus_analysis()
  152          ¹¦ÄÜ£ºÅĞ±ğ»·µº´¦Àí
  153          ²ÎÊı£ºÎŞ
  154          ËµÃ÷£º
  155          ·µ»ØÖµ£º
  156          ÈÕÆÚ£º
  157          Ô­Àí£º·Ç³£¼òµ¥£¬µ½Ô²»·£¬ÅĞ¶Ïµ½µç¸ĞÖµÔö´ó£¬ÎÒÃÇÉè¶¨Ò»¸ö¹Ì¶¨µÄËÙ¶ÈµÍËÙ£¬
  158                Í¨¹ı¼ÆÊıÑÓÊ±ÈÃ³µ×ÓÔÙÍùÇ°ÅÜÒ»µãµã¾àÀë£¨·ÀÖ¹²ÁÂ·¼ç£©£¬È»ºó¹Ì¶¨´ò½ÇÖ±½Ó¿ØÖÆ¶æ»ú´ò½Ç£¬
  159                È»ºóÒ²ÊÇÍ¨¹ı¼ÆÊıÑÓÊ±£¬³µÖ»Òª°Ñ³µÉí¹Õ½øÈ¥ÁË£¬ÎÒÃÇ¾Í»Ö¸´Õı³£Ñ­¼££¬²»ĞèÒª´¦Àí³ö»·ÎÊÌâ£¬³ö»·ºóÎÒÃÇÍ¨¹ıÍ
             -ÓÂİÒÇ»òÕß±àÂëÆ÷»òÕßÑÓÊ±°Ñ±êÖ¾Î»Çå³ı£¬
  160                È»ºó·ÀÖ¹³µ×Ó¶¶¶¯£¬ÎÒÃÇ°Ñ×ªÏòpid²ÎÊıµ÷Ğ¡ºÜ¶à£¬°ÑËÙ¶È»Ö¸´Õı³£¼´¿É¡£
  161                ÔÚµ÷ÊÔÊ±ÎÒÃÇÖ»Ğèµ÷½ÚÄÇ¸ö´ò½ÇµÄÑÓÊ±ºÍ¼ÌĞøĞĞ×ßµÄÑÓÊ±£¬ÆäËû¶¼²»ÓÃ¹Ü
  162          
  163          ÏÂÃæ´úÂë£¬ÓĞµÄ±äÁ¿»òÕßÓï¾äÏàµ±ÓÚÃ»ÓĞ×÷ÓÃ£¬¿É²Î¿¼
  164          ½ö¹©²Î¿¼£¡£¡£¡£¡£¡£¡£¡£¡£¡
  165          ****************************************************/
  166          //uint8 annulus_sucess = 0;                                                                             // Èë»·³É¹¦´ÎÊı
  167          //uint8 Left_annulus = 0;                                                                                       // ×ó»·±êÖ¾Î»
  168          uint8 Flag_Right_annulus = 0;                                                                   // ÓÒ»·±êÖ¾Î»
  169          uint8 PreFlag_Right_annulus = 0;                // ÓÒ»·Ô¤ÅĞ±êÖ¾Î»
  170          // ÓÒÈëÔ²»·
  171          void Right_Annulus(void)
  172          {
  173   1          if(Flag_Right_annulus == 0 && PreFlag_Right_annulus == 0 && Left_Xie_Adc > 3500 &&
  174   1                  Left_Adc > 3500 && Mid_Adc > 3500)
  175   1              PreFlag_Right_annulus = 1;
  176   1      
  177   1      //                              LightOn;
  178   1      
  179   1          if(PreFlag_Right_annulus >= 1 && PreFlag_Right_annulus < 30 /*&& Right_Xie_Adc > 1900 && Right_Adc > 
             -2500*/ && Flag_Right_annulus == 0)
  180   1          {
  181   2              BUZZOn;
  182   2              // LightOn;
  183   2              PreFlag_Right_annulus++;
  184   2                      if(PreFlag_Right_annulus >= 30){
  185   3                              BUZZOff;
  186   3                              Flag_Right_annulus = 1;
C251 COMPILER V5.60.0,  Direction                                                          06/07/24  23:55:37  PAGE 4   

  187   3                      }
  188   2                      Turn_PWM = 1000;
  189   2                      //go_motor(0, 4000);
  190   2              //pwm_duty(Steer_Pin, 700);
  191   2              //delay_ms(300);
  192   2              
  193   2          }
  194   1      }
  195          
  196          // ×óÈëÔ²»·
  197          void Left_Annulus(void)
  198          {
  199   1      
  200   1      }
  201          uint8 Flag_circleLand = 0;
  202          void circleLand(void){
  203   1              if(Left_Xie_Adc > 3200 && Left_Adc > 3200 && Left_Corner_Adc > 3200
  204   1                      && Mid_Adc > 3200 
  205   1                      && Right_Xie_Adc > 3200 && Right_Adc > 3200 && Right_Corner_Adc > 3200 && Flag_circleLand == 0){
  206   2                      Flag_circleLand = 1;
  207   2              }
  208   1              if(Flag_circleLand > 1 && Flag_circleLand < 15){
  209   2                      BUZZOn;
  210   2              Flag_circleLand++;
  211   2                      if(Flag_circleLand >= 15){
  212   3                              Flag_circleLand = 0;
  213   3                              BUZZOff;
  214   3                      }
  215   2                      Turn_PWM = 0;
  216   2              }
  217   1      }
  218          
  219          void Annulus_Analysis(void)
  220          {
  221   1          Right_Annulus();
  222   1          Left_Annulus();
  223   1              circleLand();
  224   1      }
  225          
  226          
  227          /***********************************¶æ»ú³õÊ¼»¯*****************************************
  228          º¯Êı£ºvoid init_Steer_PWM(void)
  229          ²ÎÊı£ºÎŞ
  230          ËµÃ÷£º·ÖÄ¸10000£¬Ê¹ÓÃ£¬ÈçĞèĞŞ¸ÄÒı½ÅĞŞ¸Ä¶ÔÓ¦ºê¶¨Òå¼´¿É
  231                 pwm_init(PWM0_P00, 100, 5000);     //³õÊ¼»¯PWM0  Ê¹ÓÃÒı½ÅP0.0  Êä³öPWMÆµÂÊ100HZ   Õ¼¿Õ±ÈÎª°Ù·ÖÖ® 5
             -000/PWM_DUTY_MAX*100
  232          //               PWM_DUTY_MAXÔÚzf_pwm.hÎÄ¼şÖĞ                           Ä¬ÈÏÎª10000
  233          *
  234          *×¢Òâ£¬ÏÈµ÷½Ú¶æ»ú£¬Èç¹û¶æ»úÎªSD05£¬ÔòÆµÂÊÎª200hz ,Èç¹û¶æ»úÎªS3010,ÆµÂÊÔòÎª50hz
  235          *ÆµÂÊÈ·¶¨ºó£¬ÏÈ°ÑÕ¼¿Õ±È·ÖÄ¸£¬¼´PWM_DUTY_MAXÈ·¶¨£¬Ò»°ãÎŞĞèĞŞ¸ÄÁË
  236          *È»ºó¾Í¿ªÊ¼µ÷½Ú¶æ»úÁË£¬µ÷Õ¼¿Õ±ÈµÄ·Ö×Ó£¬¼´µ÷ÓÃµÄº¯ÊıµÄ×îºóÄÇ¸ö²ÎÊı£¬¸ù¾İ¾­ÑéËãÒ»ÏÂ£¬´ó¸ÅÊÇ1/20µÄÕ¼¿Õ±È£¬È»
             -ºóÍù×óÍùÓÒÂıÂıÊÔ
  237          *¼ÆËã¹«Ê½£ºÖĞÖµÕ¼¿Õ±È´ó¸ÅÊÇ7.5% £¨ºÍÆµÂÊ¾«¶È¶¼ÓĞ¹ØÏµ£© 20ms(1.5ms¸ßµçÆ½)
  238          ·µ»ØÖµ£ºÎŞ
  239          **************************************************************************************/
  240          void init_Steer_PWM(void)
  241          {
  242   1          pwm_init(Steer_Pin, 50, Steer_Duty_Midle);   //³õÊ¼»¯¶æ»ú  Êä³öPWMÆµÂÊ50HZ£¬²¢ÉèÖÃÖĞÖµ
  243   1      }
  244          
  245          
  246          /*******************¶æ»ú×ªÏò¿ØÖÆÊä³ö*************************
  247          º¯Êı£ºvoid Steering_Control_Out(int16 duty)
  248          ¹¦ÄÜ£º
  249          ²ÎÊı£ºÎŞ
  250          ËµÃ÷£º¶æ»ú×ªÏò¿ØÖÆ    ×¢Òâµ÷ºÃ¶æ»úÖĞÖµºó£¬×óÓÒ¼«ÏŞÒ²µ÷³öÀ´£¬ÒªĞŞ¸ÄÉÏÃæµÄºê¶¨Òå
C251 COMPILER V5.60.0,  Direction                                                          06/07/24  23:55:37  PAGE 5   

  251          ·µ»ØÖµ£º
  252          ************************************************************/
  253          void Steering_Control_Out(int16 duty)
  254          {
  255   1          duty = Steer_Duty_Midle + duty;                                                                                                     // ÔÚ¶æ»úÖĞÖµµÄ»ù´¡ÉÏ½øĞĞÆ«ÒÆ
  256   1      
  257   1          if(duty >= Steer_Duty_Max)                                                                                                                  // ´ò½Ç¹ı´ó¾Í¼õËÙ
  258   1          {
  259   2              duty = Steer_Duty_Max;
  260   2              ClsLoop_Speed  -=  100;                                                                                                                         // ÎŞÂÛÊÇ¿ª±Õ»·×´Ì¬¶¼¼õËÙ
  261   2              OpenLoop_Speed -=  100;
  262   2          }
  263   1          else                // ·ñÔò°´ÕÕÔ­À´µÄËÙ¶ÈĞĞÊ»
  264   1          {
  265   2              OpenLoop_Speed = OpenLoop_Set_Speed;
  266   2              ClsLoop_Speed = ClsLoop_Set_Speed;
  267   2          }
  268   1      
  269   1          if(duty <= Steer_Duty_Min)                                                                                                                          // ´ò½Ç¹ı´ó¾Í¼õËÙ
  270   1          {
  271   2              duty = Steer_Duty_Min;
  272   2              ClsLoop_Speed  -=  100;                                                                                                                         // ÎŞÂÛÊÇ¿ª±Õ»·×´Ì¬¶¼¼õËÙ
  273   2              OpenLoop_Speed -=  100;
  274   2          }
  275   1          else        // ·ñÔò°´ÕÕÔ­À´µÄËÙ¶ÈĞĞÊ»
  276   1          {
  277   2              OpenLoop_Speed = OpenLoop_Set_Speed;
  278   2              ClsLoop_Speed = ClsLoop_Set_Speed;
  279   2          }
  280   1      
  281   1          pwm_duty(Steer_Pin, duty);
  282   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1343     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       140     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        93     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
