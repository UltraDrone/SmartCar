C251 COMPILER V5.60.0,  Direction                                                          03/07/24  19:16:17  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Direction
OBJECT MODULE PLACED IN .\Out_File\Direction.obj
COMPILER INVOKED BY: G:\Keil_v5\C251\C251\BIN\C251.EXE ..\CODE\Direction.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED
                    -) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE
                    -;..\USER\inc;..\USER\src;..\CODE) DEBUG PRINT(.\Out_File\Direction.lst) OBJECT(.\Out_File\Direction.obj) 

stmt  level    source

    1          #include "Direction.h"
    2          
    3          // ADC²É¼¯Öµ
    4          // Êı×éË÷Òı0~4·Ö±ğÎª
    5          // ×óµç¸Ğ×îÖÕÖµ  ÓÒµç¸Ğ×îÖÕÖµ  ×óĞ±µç¸Ğ×îÖÕÖµ  ÓÒĞ±µç¸Ğ×îÖÕÖµ  ÖĞ¼äµç¸Ğ×îÖÕÖµ
    6          uint16  adc_date[7];                                                             // ´¢´æµç¸Ğ²É¼¯Öµ Ô­Ê¼Öµ 5¸öµç¸Ğ
    7          
    8          // ADCÏŞ·ùÖµ
    9          uint16 adc_max[7] = {2000, 2000, 2200, 2200, 2200, 2200, 2000};      // ×î´óÖµ
   10          uint16 adc_min[7] = {0, 0, 100, 100, 100, 100, 100};                             // ×îĞ¡Öµ  (¸ø¶¨Ò»¸öĞèÒª)
   11          
   12          int16  adc_deviation;                                                                                                            // µç¸ĞÆ«²î
   13          int go_flag;
   14          // ADC²É¼¯×îÖÕÖµ
   15          int16 Left_Adc = 0, Right_Adc = 0, Mid_Adc = 0, Left_Xie_Adc = 0, Right_Xie_Adc = 0, Left_Corner_Adc = 0,
             - Right_Corner_Adc = 0;         //µç¸ĞÖµ
   16          
   17          /****************ADC³õÊ¼»¯**************************
   18          º¯  Êı£ºvoid ADC_Init(void)
   19          ¹¦  ÄÜ£ºADCÍ¨µÀÒı½Å³õÊ¼»¯
   20          ²Î  Êı£ºÎŞ
   21          Ëµ  Ã÷£ºADC_Init(ADC_P10,ADC_SYSclk_DIV_2);//³õÊ¼»¯P1.0ÎªADC¹¦ÄÜ,ADCÊ±ÖÓÆµÂÊ£ºSYSclk/2
   22          Òı  ½Å£º¼ûÍ·ÎÄ¼ş¶¨Òå
   23          ·µ»ØÖµ£ºÎŞ
   24          ***************************************************/
   25          void Analog_Digital_Converter_Init(void)
   26          {
   27   1          adc_init(Left_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   28   1          adc_init(LeftXie_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   29   1          adc_init(Mid_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   30   1          adc_init(RightXie_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   31   1          adc_init(Right_ADC_Pin, ADC_SYSclk_DIV_2); //³õÊ¼»¯ADC¹¦ÄÜ
   32   1              adc_init(LeftCorner_ADC_Pin,ADC_SYSclk_DIV_2);//³õÊ¼»¯ADC¹¦ÄÜ
   33   1              adc_init(RightCorner_ADC_Pin,ADC_SYSclk_DIV_2);//³õÊ¼»¯ADC¹¦ÄÜ
   34   1      }
   35          
   36          
   37          /****************µç¸Ğ²É¼¯**************************
   38          º¯  Êı£ºvoid ADC_MAX_Collect(void)
   39          ¹¦  ÄÜ£º
   40          ²Î  Êı£ºÎŞ
   41          Ëµ  Ã÷£ºµ÷ÓÃ¿âº¯Êı£¨×Ô¼ºĞ´µÄ£©    adc_mean_filter (ADC_P10, ADC_12BIT, 10)
   42          ·µ»ØÖµ£ºÎŞ
   43          **************************************************/
   44          void ADC_MAX_Collect(void)
   45          {
   46   1          int i, j;
   47   1      
   48   1          for(i = 600; i > 0; i--)
   49   1          {
   50   2              adc_date[0] = adc_mean_filter(Left_ADC_Pin, ADC_12BIT, 2);
   51   2              adc_date[1] = adc_mean_filter(Right_ADC_Pin, ADC_12BIT, 2);
   52   2              adc_date[2] = adc_mean_filter(LeftXie_ADC_Pin, ADC_12BIT, 2);
   53   2              adc_date[3] = adc_mean_filter(RightXie_ADC_Pin, ADC_12BIT, 2);
   54   2                      adc_date[4] = adc_mean_filter(LeftCorner_ADC_Pin, ADC_12BIT, 2);
   55   2              adc_date[5] = adc_mean_filter(RightCorner_ADC_Pin, ADC_12BIT, 2);
   56   2              adc_date[6] = adc_mean_filter(Mid_ADC_Pin, ADC_12BIT, 2);
C251 COMPILER V5.60.0,  Direction                                                          03/07/24  19:16:17  PAGE 2   

   57   2      
   58   2              for(j = 0; j < 7; j++)                                                                  // Èı¸öºáµç¸Ğ×÷ÏŞ·ù
   59   2              {
   60   3                  if(adc_date[j] >= adc_max[j])                                                       // ÉÏÏŞ·ù
   61   3                      adc_max[j] = adc_date[j];
   62   3      
   63   3                              if(adc_date[j] <= adc_min[j])                                                   // ÏÂÏŞ·ù
   64   3                                      adc_min[j] = adc_date[j];
   65   3                  delay_ms(2);//ÑÓÊ±²É¼¯
   66   3              }
   67   2          }
   68   1      }
   69          
   70          /****************µç¸Ğ²É¼¯**************************
   71          º¯  Êı£ºvoid AD_Date_Fitier()
   72          ¹¦  ÄÜ£º¶Ôµç¸Ğ²ÉÖµ½øĞĞÃ°ÅİÅÅĞò»¬¶¯ÂË²¨
   73          ²Î  Êı£ºÎŞ
   74          Ëµ  Ã÷£º12bit  4096   µ÷ÓÃ¿âº¯Êı£¨×Ô¼ºĞ´µÄ£©    adc_mean_filter(ADC_P10, ADC_12BIT, 10)
   75          ·µ»ØÖµ£ºÎŞ
   76          **************************************************/
   77          #define FILTER_N 5 //ÂË²¨Éî¶È
   78          
   79          void AD_Date_Fitier(void)
   80          {
   81   1          uint8 i;
   82   1          int16 filter_buf_L[FILTER_N];  //×óºáµç¸Ğ´¢´æÊı×é
   83   1          int16 filter_buf_LC[FILTER_N]; //×óĞ±µç¸Ğ´¢´æÊı×é
   84   1              int16 filter_buf_LX[FILTER_N]; //×óĞ±µç¸Ğ´¢´æÊı×é
   85   1          int16 filter_buf_M[FILTER_N];  //ÖĞºáµç¸Ğ´¢´æÊı×é
   86   1          int16 filter_buf_R[FILTER_N];  //ÓÒºáµç¸Ğ´¢´æÊı×é
   87   1          int16 filter_buf_RC[FILTER_N];  //ÓÒĞ±µç¸Ğ´¢´æÊı×é
   88   1              int16 filter_buf_RX[FILTER_N]; //×óĞ±µç¸Ğ´¢´æÊı×é
   89   1      
   90   1          //--------»¬¶¯ÂË²¨--------------
   91   1          for(i = 0; i < FILTER_N; i++)       //²ÉÖµ
   92   1          {
   93   2              filter_buf_L[i]  = adc_mean_filter(Left_ADC_Pin, ADC_12BIT, 10); //×óºá
   94   2              filter_buf_LX[i] = adc_mean_filter(LeftXie_ADC_Pin, ADC_12BIT, 5); //×óĞ±
   95   2                      filter_buf_LC[i] = adc_mean_filter(LeftCorner_ADC_Pin, ADC_12BIT, 5); //×óĞ±
   96   2              filter_buf_M[i]  = adc_mean_filter(Mid_ADC_Pin, ADC_12BIT, 5); //ÖĞ¼ä
   97   2              filter_buf_RC[i] = adc_mean_filter(RightCorner_ADC_Pin, ADC_12BIT, 5);  //ÓÒĞ±
   98   2                      filter_buf_RX[i] = adc_mean_filter(RightXie_ADC_Pin, ADC_12BIT, 5); //×óĞ±
   99   2              filter_buf_R[i]  = adc_mean_filter(Right_ADC_Pin, ADC_12BIT, 10); //ÓÒºá
  100   2          }
  101   1              //13 14 16 05 01 00
  102   1              //567321
  103   1      
  104   1          //--------Ã°ÅİÅÅĞòÈ¥¼«ÖµÇóÆ½¾ù---------
  105   1          adc_date[0] = I_Median_Average_Filter(filter_buf_L);  //×ó    3600
  106   1          adc_date[1] = I_Median_Average_Filter(filter_buf_R);  //ÓÒ    3600
  107   1          adc_date[2] = I_Median_Average_Filter(filter_buf_LX); //×óĞ±  3000
  108   1          adc_date[3] = I_Median_Average_Filter(filter_buf_RX); //ÓÒĞ±
  109   1              adc_date[4] = I_Median_Average_Filter(filter_buf_LC); //×óĞ±  3000
  110   1          adc_date[5] = I_Median_Average_Filter(filter_buf_RC); //ÓÒĞ±
  111   1          adc_date[6] = I_Median_Average_Filter(filter_buf_M);  //ÖĞ¼ä  4050
  112   1      
  113   1          Left_Adc = adc_date[0];                                                           //×óµç¸Ğ×îÖÕÖµ
  114   1          Right_Adc = adc_date[1];                                                  //ÓÒµç¸Ğ×îÖÕÖµ
  115   1          Left_Xie_Adc = adc_date[2];                                               //×óĞ±µç¸Ğ×îÖÕÖµ
  116   1          Right_Xie_Adc = adc_date[3];                                              //ÓÒĞ±µç¸Ğ×îÖÕÖµ
  117   1              Left_Corner_Adc = adc_date[4];
  118   1              Right_Corner_Adc = adc_date[5];
  119   1          Mid_Adc = adc_date[6];                                                            //ÖĞ¼äµç¸Ğ×îÖÕÖµ
  120   1      }
  121          
  122          void Protect_Anticollision(void)
C251 COMPILER V5.60.0,  Direction                                                          03/07/24  19:16:17  PAGE 3   

  123          {
  124   1          if(Left_Adc < 100 && Right_Adc < 100){
  125   2              //Flag.start_go = 0;
  126   2                      go_flag = 0;
  127   2              }else
  128   1              if(Left_Adc > 150 || Right_Adc > 150){
  129   2                      //Flag.start_go = 1;
  130   2                      go_flag = 1;
  131   2              }
  132   1      }
  133          
  134          
  135          /*************************************
  136          º¯Êı£ºvoid Electromagnetism_Control(void)
  137          ¹¦ÄÜ£ºµç´Å¿ØÖÆ
  138          ²ÎÊı£ºÎŞ
  139          ËµÃ÷£º
  140          **************************************/
  141          void Electromagnetism_Control(void)
  142          {
  143   1          AD_Date_Fitier();                  // µç¸Ğ²É¼¯´¦Àí Ã°ÅİÅÅĞò»¬¶¯ÂË²¨
  144   1          
  145   1          /// normalize_date();               // ²É¼¯µç¸Ğ¹éÒ»»¯  0--100 ²»ÄÜÓÃ£¬Î´ÕÒµ½Ô­Òò£¬²»Òª¹éÒ»»¯À²
  146   1          Protect_Anticollision();                                            // ±£»¤
  147   1      }
  148          
  149          /*****************»·µº´¦Àí´úÂë***********************
  150          º¯Êı£ºvoid  annulus_analysis()
  151          ¹¦ÄÜ£ºÅĞ±ğ»·µº´¦Àí
  152          ²ÎÊı£ºÎŞ
  153          ËµÃ÷£º
  154          ·µ»ØÖµ£º
  155          ÈÕÆÚ£º
  156          Ô­Àí£º·Ç³£¼òµ¥£¬µ½Ô²»·£¬ÅĞ¶Ïµ½µç¸ĞÖµÔö´ó£¬ÎÒÃÇÉè¶¨Ò»¸ö¹Ì¶¨µÄËÙ¶ÈµÍËÙ£¬
  157                Í¨¹ı¼ÆÊıÑÓÊ±ÈÃ³µ×ÓÔÙÍùÇ°ÅÜÒ»µãµã¾àÀë£¨·ÀÖ¹²ÁÂ·¼ç£©£¬È»ºó¹Ì¶¨´ò½ÇÖ±½Ó¿ØÖÆ¶æ»ú´ò½Ç£¬
  158                È»ºóÒ²ÊÇÍ¨¹ı¼ÆÊıÑÓÊ±£¬³µÖ»Òª°Ñ³µÉí¹Õ½øÈ¥ÁË£¬ÎÒÃÇ¾Í»Ö¸´Õı³£Ñ­¼££¬²»ĞèÒª´¦Àí³ö»·ÎÊÌâ£¬³ö»·ºóÎÒÃÇÍ¨¹ıÍ
             -ÓÂİÒÇ»òÕß±àÂëÆ÷»òÕßÑÓÊ±°Ñ±êÖ¾Î»Çå³ı£¬
  159                È»ºó·ÀÖ¹³µ×Ó¶¶¶¯£¬ÎÒÃÇ°Ñ×ªÏòpid²ÎÊıµ÷Ğ¡ºÜ¶à£¬°ÑËÙ¶È»Ö¸´Õı³£¼´¿É¡£
  160                ÔÚµ÷ÊÔÊ±ÎÒÃÇÖ»Ğèµ÷½ÚÄÇ¸ö´ò½ÇµÄÑÓÊ±ºÍ¼ÌĞøĞĞ×ßµÄÑÓÊ±£¬ÆäËû¶¼²»ÓÃ¹Ü
  161          
  162          ÏÂÃæ´úÂë£¬ÓĞµÄ±äÁ¿»òÕßÓï¾äÏàµ±ÓÚÃ»ÓĞ×÷ÓÃ£¬¿É²Î¿¼
  163          ½ö¹©²Î¿¼£¡£¡£¡£¡£¡£¡£¡£¡£¡
  164          ****************************************************/
  165          //uint8 annulus_sucess = 0;                                                                             // Èë»·³É¹¦´ÎÊı
  166          //uint8 Left_annulus = 0;                                                                                       // ×ó»·±êÖ¾Î»
  167          uint8 Flag_Right_annulus = 0;                                                                   // ÓÒ»·±êÖ¾Î»
  168          uint8 PreFlag_Right_annulus = 0;                // ÓÒ»·Ô¤ÅĞ±êÖ¾Î»
  169          // ÓÒÈëÔ²»·
  170          void Right_Annulus(void)
  171          {
  172   1          if(Flag_Right_annulus == 0 && PreFlag_Right_annulus == 0 && Left_Xie_Adc > 3500 &&
  173   1                  Left_Adc > 3500 && Mid_Adc > 3500)
  174   1              PreFlag_Right_annulus = 1;
  175   1      
  176   1      //                              LightOn;
  177   1      
  178   1          if(PreFlag_Right_annulus == 1 /*&& Right_Xie_Adc > 1900 && Right_Adc > 2500*/ && Flag_Right_annulus =
             -= 0)
  179   1          {
  180   2              BUZZOn;
  181   2              // LightOn;
  182   2              PreFlag_Right_annulus = 0;
  183   2                      Flag_Right_annulus = 1;
  184   2                      //Turn_PWM = 1000;
  185   2              //pwm_duty(Steer_Pin, 700);
  186   2              delay_ms(300);
C251 COMPILER V5.60.0,  Direction                                                          03/07/24  19:16:17  PAGE 4   

  187   2              BUZZOff;
  188   2          }
  189   1      }
  190          
  191          // ×óÈëÔ²»·
  192          void Left_Annulus(void)
  193          {
  194   1      
  195   1      }
  196          
  197          void Annulus_Analysis(void)
  198          {
  199   1          Right_Annulus();
  200   1          Left_Annulus();
  201   1      }
  202          
  203          
  204          /***********************************¶æ»ú³õÊ¼»¯*****************************************
  205          º¯Êı£ºvoid init_Steer_PWM(void)
  206          ²ÎÊı£ºÎŞ
  207          ËµÃ÷£º·ÖÄ¸10000£¬Ê¹ÓÃ£¬ÈçĞèĞŞ¸ÄÒı½ÅĞŞ¸Ä¶ÔÓ¦ºê¶¨Òå¼´¿É
  208                 pwm_init(PWM0_P00, 100, 5000);     //³õÊ¼»¯PWM0  Ê¹ÓÃÒı½ÅP0.0  Êä³öPWMÆµÂÊ100HZ   Õ¼¿Õ±ÈÎª°Ù·ÖÖ® 5
             -000/PWM_DUTY_MAX*100
  209          //               PWM_DUTY_MAXÔÚzf_pwm.hÎÄ¼şÖĞ                           Ä¬ÈÏÎª10000
  210          *
  211          *×¢Òâ£¬ÏÈµ÷½Ú¶æ»ú£¬Èç¹û¶æ»úÎªSD05£¬ÔòÆµÂÊÎª200hz ,Èç¹û¶æ»úÎªS3010,ÆµÂÊÔòÎª50hz
  212          *ÆµÂÊÈ·¶¨ºó£¬ÏÈ°ÑÕ¼¿Õ±È·ÖÄ¸£¬¼´PWM_DUTY_MAXÈ·¶¨£¬Ò»°ãÎŞĞèĞŞ¸ÄÁË
  213          *È»ºó¾Í¿ªÊ¼µ÷½Ú¶æ»úÁË£¬µ÷Õ¼¿Õ±ÈµÄ·Ö×Ó£¬¼´µ÷ÓÃµÄº¯ÊıµÄ×îºóÄÇ¸ö²ÎÊı£¬¸ù¾İ¾­ÑéËãÒ»ÏÂ£¬´ó¸ÅÊÇ1/20µÄÕ¼¿Õ±È£¬È»
             -ºóÍù×óÍùÓÒÂıÂıÊÔ
  214          *¼ÆËã¹«Ê½£ºÖĞÖµÕ¼¿Õ±È´ó¸ÅÊÇ7.5% £¨ºÍÆµÂÊ¾«¶È¶¼ÓĞ¹ØÏµ£© 20ms(1.5ms¸ßµçÆ½)
  215          ·µ»ØÖµ£ºÎŞ
  216          **************************************************************************************/
  217          void init_Steer_PWM(void)
  218          {
  219   1          pwm_init(Steer_Pin, 50, Steer_Duty_Midle);   //³õÊ¼»¯¶æ»ú  Êä³öPWMÆµÂÊ50HZ£¬²¢ÉèÖÃÖĞÖµ
  220   1      }
  221          
  222          
  223          /*******************¶æ»ú×ªÏò¿ØÖÆÊä³ö*************************
  224          º¯Êı£ºvoid Steering_Control_Out(int16 duty)
  225          ¹¦ÄÜ£º
  226          ²ÎÊı£ºÎŞ
  227          ËµÃ÷£º¶æ»ú×ªÏò¿ØÖÆ    ×¢Òâµ÷ºÃ¶æ»úÖĞÖµºó£¬×óÓÒ¼«ÏŞÒ²µ÷³öÀ´£¬ÒªĞŞ¸ÄÉÏÃæµÄºê¶¨Òå
  228          ·µ»ØÖµ£º
  229          ************************************************************/
  230          void Steering_Control_Out(int16 duty)
  231          {
  232   1          duty = Steer_Duty_Midle + duty;                                                                                                     // ÔÚ¶æ»úÖĞÖµµÄ»ù´¡ÉÏ½øĞĞÆ«ÒÆ
  233   1      
  234   1          if(duty >= Steer_Duty_Max)                                                                                                                  // ´ò½Ç¹ı´ó¾Í¼õËÙ
  235   1          {
  236   2              duty = Steer_Duty_Max;
  237   2              ClsLoop_Speed  -=  100;                                                                                                                         // ÎŞÂÛÊÇ¿ª±Õ»·×´Ì¬¶¼¼õËÙ
  238   2              OpenLoop_Speed -=  100;
  239   2          }
  240   1          else                // ·ñÔò°´ÕÕÔ­À´µÄËÙ¶ÈĞĞÊ»
  241   1          {
  242   2              OpenLoop_Speed = OpenLoop_Set_Speed;
  243   2              ClsLoop_Speed = ClsLoop_Set_Speed;
  244   2          }
  245   1      
  246   1          if(duty <= Steer_Duty_Min)                                                                                                                          // ´ò½Ç¹ı´ó¾Í¼õËÙ
  247   1          {
  248   2              duty = Steer_Duty_Min;
  249   2              ClsLoop_Speed  -=  100;                                                                                                                         // ÎŞÂÛÊÇ¿ª±Õ»·×´Ì¬¶¼¼õËÙ
  250   2              OpenLoop_Speed -=  100;
C251 COMPILER V5.60.0,  Direction                                                          03/07/24  19:16:17  PAGE 5   

  251   2          }
  252   1          else        // ·ñÔò°´ÕÕÔ­À´µÄËÙ¶ÈĞĞÊ»
  253   1          {
  254   2              OpenLoop_Speed = OpenLoop_Set_Speed;
  255   2              ClsLoop_Speed = ClsLoop_Set_Speed;
  256   2          }
  257   1      
  258   1          pwm_duty(Steer_Pin, duty);
  259   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1135     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       139     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        88     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
