C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_PRINTF
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_PRINTF.obj
COMPILER INVOKED BY: G:\Keil_v5\C251\C251\BIN\C251.EXE ..\..\Libraries\seekfree_peripheral\SEEKFREE_PRINTF.c XSMALL INTR
                    -2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Lib
                    -raries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;..\CODE) DEBUG PRINT(.\Out_File\SEEKFREE_PRINTF.lst) OBJECT(.
                    -\Out_File\SEEKFREE_PRINTF.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * COPYRIGHT NOTICE
    3           * Copyright (c) 2018,逐飞科技
    4           * All rights reserved.
    5           * 技术讨论QQ群：一群：179029047(已满)  二群：244861897
    6           *
    7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
    8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
    9           *
   10           * @file                SEEKFREE_PRINTF
   11           * @company                     成都逐飞科技有限公司
   12           * @author              逐飞科技(QQ3184284598)
   13           * @version             查看doc内version文件 版本说明
   14           * @Software            MDK FOR C251 V5.60
   15           * @Target core         STC32G12K128
   16           * @Taobao              https://seekfree.taobao.com/
   17           * @date                2019-04-30
   18           * @note                    示波器下载地址：https://pan.baidu.com/s/198CMXTZsbI3HAEqNXDngBw（包含清华直立方案资料）
   19           ********************************************************************************************************
             -************/
   20          
   21          
   22          
   23          #include <stdarg.h>
   24          #include <string.h>
   25          
   26          #include "SEEKFREE_PRINTF.h"
   27          
   28          
   29          uint8 number_conversion_ascii(uint32 dat, int8 *p, uint8 neg_type, uint8 radix)
   30          {
   31   1          int32   neg_dat;
   32   1          uint32  pos_dat;
   33   1          uint8   temp_data = 0;
   34   1          uint8   valid_num = 0;
   35   1      
   36   1          if(neg_type)
   37   1          {
   38   2              neg_dat = (int32)dat;
   39   2      
   40   2              if(neg_dat < 0)   neg_dat = -neg_dat;
   41   2      
   42   2              while(1)
   43   2              {
   44   3                  *p = neg_dat % radix + '0';
   45   3                  neg_dat = neg_dat / radix;
   46   3                  valid_num++;
   47   3      
   48   3                  if(!neg_dat) break;
   49   3      
   50   3                  p++;
   51   3              }
   52   2          }
   53   1          else
   54   1          {
C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 2   

   55   2              pos_dat = dat;
   56   2      
   57   2              while(1)
   58   2              {
   59   3                  temp_data = pos_dat % radix;
   60   3      
   61   3                  if(10 <= temp_data) temp_data += 'A' - 10;
   62   3                  else                temp_data += '0';
   63   3      
   64   3                  *p = temp_data;
   65   3      
   66   3                  pos_dat = pos_dat / radix;
   67   3                  valid_num++;
   68   3      
   69   3                  if(!pos_dat) break;
   70   3      
   71   3                  p++;
   72   3              }
   73   2          }
   74   1      
   75   1          return valid_num;
   76   1      }
   77          
   78          void printf_reverse_order(int8 *d_buff, uint32 len)
   79          {
   80   1          uint32 i;
   81   1          int8  temp_data;
   82   1      
   83   1          for(i = 0; i < len / 2; i++)
   84   1          {
   85   2              temp_data = d_buff[len - 1 - i];
   86   2              d_buff[len - 1 - i] = d_buff[i];
   87   2              d_buff[i] = temp_data;
   88   2          }
   89   1      }
   90          
   91          
   92          //void printf(const int8 *format, ...)
   93          //{
   94          //#if(PRINTF)     //如果宏定义PRINTF为0 则不编译printf函数内容，调用printf没有任何操作
   95          //    va_list arg;
   96          //      va_start(arg, format);
   97          //
   98          //      while (*format)
   99          //      {
  100          //              int8 ret = *format;
  101          //              if (ret == '%')
  102          //              {
  103          //                      switch (*++format)
  104          //                      {
  105          //                case 'a':// 十六进制p计数法输出浮点数 暂未实现
  106          //                {
  107          //
  108          //
  109          //                }break;
  110          //
  111          //
  112          //                case 'c':// 一个字符
  113          //                {
  114          //                    int8 ch = (int8)va_arg(arg, uint32);
  115          //                    uart_putchar(DEBUG_UART, (int8)ch);
  116          //
  117          //                }break;
  118          //
  119          //
  120          //                case 'd':
C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 3   

  121          //                case 'i':// 有符号十进制整数
  122          //                {
  123          //                    int8 vstr[33];
  124          //                    int32 ival = (int32)va_arg(arg, int32);
  125          //                    uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  126          //                    if(ival<0)  uart_putchar(DEBUG_UART, '-');
  127          //                    printf_reverse_order(vstr,vlen);
  128          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,vlen);
  129          //                }break;
  130          //
  131          //                case 'f':// 浮点数，输出小数点后六位  不能指定输出精度
  132          //                case 'F':// 浮点数，输出小数点后六位  不能指定输出精度
  133          //                {
  134          //                    int8 vstr[33];
  135          //                    double ival = (double)va_arg(arg, double);
  136          //                    uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  137          //                    if(ival<0)  uart_putchar(DEBUG_UART, '-');
  138          //                    printf_reverse_order(vstr,vlen);
  139          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,vlen);
  140          //                    uart_putchar(DEBUG_UART, '.');
  141          
  142          //                    ival = ((double)ival - (int32)ival)*1000000;
  143          //                    vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  144          //                                    while(6>vlen)
  145          //                    {
  146          //                        vstr[vlen] = '0';
  147          //                        vlen++;
  148          //                    }
  149          //                    printf_reverse_order(vstr,vlen);
  150          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,vlen);
  151          //                    break;
  152          //                }
  153          //
  154          //                case 'u':// 无符号十进制整数
  155          //                {
  156          //                    int8 vstr[33];
  157          //                    uint32 ival = (uint32)va_arg(arg, uint32);
  158          //                    uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  159          //                    printf_reverse_order(vstr,vlen);
  160          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,vlen);
  161          //                }break;
  162          //
  163          //                case 'o':// 无符号八进制整数
  164          //                {
  165          //                    int8 vstr[33];
  166          //                    uint32 ival = (uint32)va_arg(arg, uint32);
  167          //                    uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  168          //                    printf_reverse_order(vstr,vlen);
  169          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,vlen);
  170          //
  171          //                }break;
  172          //
  173          //                case 'x':// 无符号十六进制整数
  174          //                case 'X':// 无符号十六进制整数
  175          //                {
  176          //                    int8 vstr[33];
  177          //                    uint32 ival = (uint32)va_arg(arg, uint32);
  178          //                    uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  179          //                    printf_reverse_order(vstr,vlen);
  180          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,vlen);
  181          //                }break;
  182          //
  183          //
  184          //                case 's':// 字符串
  185          //                {
  186          //                    int8 *pc = va_arg(arg, int8 *);
C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 4   

  187          //                    while (*pc)
  188          //                    {
  189          //                        uart_putchar(DEBUG_UART, (int8)(*pc));
  190          //                        pc++;
  191          //                    }
  192          //                }break;
  193          //
  194          //                case 'p':// 以16进制形式输出指针
  195          //                {
  196          //                    int8 vstr[33];
  197          //                    uint32 ival = (uint32)va_arg(arg, uint32);
  198          //                    uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  199          //                    printf_reverse_order(vstr,8);
  200          //                    uart_putbuff(DEBUG_UART, (uint8 *)vstr,8);
  201          //
  202          //                }break;
  203          //
  204          //
  205          //                case '%':// 输出字符%
  206          //                {
  207          //                    uart_putchar(DEBUG_UART, '%');
  208          //                }break;
  209          
  210          //                default:break;
  211          //                      }
  212          //              }
  213          //              else
  214          //              {
  215          //                      uart_putchar(DEBUG_UART, (int8)(*format));
  216          //              }
  217          //              format++;
  218          //      }
  219          //      va_end(arg);
  220          //#endif
  221          //}
  222          
  223          
  224          uint32 zf_sprintf(char  *buff, const int8 *format, ...)
  225          {
  226   1          uint32 buff_len = 0;
  227   1          va_list arg;
  228   1          va_start(arg, format);
  229   1      
  230   1          while (*format)
  231   1          {
  232   2              int8 ret = *format;
  233   2      
  234   2              if (ret == '%')
  235   2              {
  236   3                  switch (*++format)
  237   3                  {
  238   4                      case 'a':// 十六进制p计数法输出浮点数 暂未实现
  239   4                      {
  240   5      
  241   5      
  242   5                      } break;
  243   4      
  244   4      
  245   4                      case 'c':// 一个字符
  246   4                      {
  247   5                          int8 ch = (int8)va_arg(arg, uint32);
  248   5                          *buff = ch;
  249   5                          buff++;
  250   5                          buff_len++;
  251   5      
  252   5                      }
C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 5   

  253   4                      break;
  254   4      
  255   4      
  256   4                      case 'd':
  257   4                      case 'i':// 有符号十进制整数
  258   4                      {
  259   5                          int8 vstr[33];
  260   5                          int32 ival = (int32)va_arg(arg, int32);
  261   5                          uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  262   5      
  263   5                          if(ival < 0)
  264   5                          {
  265   6                              vstr[vlen] = '-';
  266   6                              vlen++;
  267   6                          }
  268   5      
  269   5                          printf_reverse_order(vstr, vlen);
  270   5                          memcpy(buff, vstr, vlen);
  271   5                          buff += vlen;
  272   5                          buff_len += vlen;
  273   5      
  274   5      
  275   5                      }
  276   4                      break;
  277   4      
  278   4                      case 'f':// 浮点数，输出小数点后六位  不能指定输出精度
  279   4                      case 'F':// 浮点数，输出小数点后六位  不能指定输出精度
  280   4                      {
  281   5                          int8 vstr[33];
  282   5                          double ival = (double)va_arg(arg, double);
  283   5                          uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  284   5      
  285   5                          if(ival < 0)
  286   5                          {
  287   6                              vstr[vlen] = '-';
  288   6                              vlen++;
  289   6                          }
  290   5      
  291   5                          printf_reverse_order(vstr, vlen);
  292   5                          memcpy(buff, vstr, vlen);
  293   5                          buff += vlen;
  294   5                          buff_len += vlen;
  295   5      
  296   5                          ival = ((double)ival - (int32)ival) * 1000000;
  297   5      
  298   5                          if(ival)
  299   5                          {
  300   6                              vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  301   6                          }
  302   5                          else
  303   5                          {
  304   6                              vstr[0] = vstr[1] = vstr[2] = vstr[3] = vstr[4] = vstr[5] = '0';
  305   6                              vlen = 6;
  306   6                          }
  307   5      
  308   5                          while(6 > vlen)
  309   5                          {
  310   6                              vstr[vlen] = '0';
  311   6                              vlen++;
  312   6                          }
  313   5      
  314   5                          vstr[vlen] = '.';
  315   5                          vlen++;
  316   5      
  317   5                          printf_reverse_order(vstr, vlen);
  318   5                          memcpy(buff, vstr, vlen);
C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 6   

  319   5                          buff_len += vlen;
  320   5      
  321   5                          break;
  322   5                      }
  323   4      
  324   4                      case 'u':// 无符号十进制整数
  325   4                      {
  326   5                          int8 vstr[33];
  327   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  328   5                          uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  329   5      
  330   5                          printf_reverse_order(vstr, vlen);
  331   5                          memcpy(buff, vstr, vlen);
  332   5                          buff += vlen;
  333   5                          buff_len += vlen;
  334   5                      }
  335   4                      break;
  336   4      
  337   4                      case 'o':// 无符号八进制整数
  338   4                      {
  339   5                          int8 vstr[33];
  340   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  341   5                          uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  342   5      
  343   5                          printf_reverse_order(vstr, vlen);
  344   5                          memcpy(buff, vstr, vlen);
  345   5                          buff += vlen;
  346   5                          buff_len += vlen;
  347   5      
  348   5                      }
  349   4                      break;
  350   4      
  351   4                      case 'x':// 无符号十六进制整数
  352   4                      case 'X':// 无符号十六进制整数
  353   4                      {
  354   5                          int8 vstr[33];
  355   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  356   5                          uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  357   5      
  358   5                          printf_reverse_order(vstr, vlen);
  359   5                          memcpy(buff, vstr, vlen);
  360   5                          buff += vlen;
  361   5                          buff_len += vlen;
  362   5                      }
  363   4                      break;
  364   4      
  365   4      
  366   4                      case 's':// 字符串
  367   4                      {
  368   5                          int8 *pc = va_arg(arg, int8 *);
  369   5      
  370   5                          while (*pc)
  371   5                          {
  372   6                              *buff = *pc;
  373   6                              buff++;
  374   6                              buff_len++;
  375   6                              pc++;
  376   6                          }
  377   5                      }
  378   4                      break;
  379   4      
  380   4                      case 'p':// 以16进制形式输出指针
  381   4                      {
  382   5                          int8 vstr[33];
  383   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  384   5                          //uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
C251 COMPILER V5.60.0,  SEEKFREE_PRINTF                                                    06/07/24  23:05:06  PAGE 7   

  385   5                          number_conversion_ascii(ival, vstr, 0, 16);
  386   5      
  387   5                          printf_reverse_order(vstr, 8);
  388   5                          memcpy(buff, vstr, 8);
  389   5                          buff += 8;
  390   5                          buff_len += 8;
  391   5      
  392   5                      }
  393   4                      break;
  394   4      
  395   4      
  396   4                      case '%':// 输出字符%
  397   4                      {
  398   5                          *buff = '%';
  399   5                          buff++;
  400   5                          buff_len++;
  401   5                      }
  402   4                      break;
  403   4      
  404   4                      default:
  405   4                          break;
  406   4                  }
  407   3              }
  408   2              else
  409   2              {
  410   3                  *buff = (int8)(*format);
  411   3                  buff++;
  412   3                  buff_len++;
  413   3              }
  414   2      
  415   2              format++;
  416   2          }
  417   1      
  418   1          va_end(arg);
  419   1      
  420   1          return buff_len;
  421   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2045     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       128     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
