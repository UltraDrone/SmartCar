C251 COMPILER V5.60.0,  zf_fifo                                                            06/07/24  23:05:05  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_fifo
OBJECT MODULE PLACED IN .\Out_File\zf_fifo.obj
COMPILER INVOKED BY: G:\Keil_v5\C251\C251\BIN\C251.EXE ..\..\Libraries\seekfree_libraries\zf_fifo.c XSMALL INTR2 WARNING
                    -LEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\se
                    -ekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;..\CODE) DEBUG PRINT(.\Out_File\zf_fifo.lst) OBJECT(.\Out_File\zf_fifo
                    -.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * COPYRIGHT NOTICE
    3           * Copyright (c) 2020,逐飞科技
    4           * All rights reserved.
    5           * 技术讨论QQ群：一群：179029047(已满)  二群：244861897(已满)  三群：824575535
    6           *
    7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
    8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
    9           *
   10           * @file                fifo
   11           * @company                     成都逐飞科技有限公司
   12           * @author              逐飞科技(QQ790875685)
   13           * @version             查看doc内version文件 版本说明
   14           * @Software            MDK FOR C251 V5.60
   15           * @Target core         STC32G12K128
   16           * @Taobao              https://seekfree.taobao.com/
   17           * @date                2020-4-14
   18           ********************************************************************************************************
             -************/
   19          
   20          
   21          
   22          #include "stdio.h"
   23          #include "string.h"
   24          #include "board.h"
   25          #include "zf_gpio.h"
   26          #include "zf_uart.h"
   27          #include "zf_nvic.h"
   28          #include "zf_delay.h"
   29          #include "zf_fifo.h"
   30          
   31          
   32          
   33          
   34          //-------------------------------------------------------------------------------------------------------
             -------------
   35          // @brief       FIFO 初始化 挂载对应缓冲区
   36          // @param       *fifo           FIFO 对象指针
   37          // @param       *buffer_addr    要挂载的缓冲区
   38          // @param       size            缓冲区大小
   39          // @return      fifo_state_enum 操作状态
   40          // Sample usage:
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          fifo_state_enum fifo_init (fifo_struct *fifo, uint8 *buffer_addr, uint32 size)
   43          {
   44   1          if(buffer_addr == NULL)
   45   1              return FIFO_BUFFER_NULL;
   46   1      
   47   1          fifo->buffer    = buffer_addr;
   48   1          fifo->head      = 0;
   49   1          fifo->end       = 0;
   50   1          fifo->size      = size;
   51   1          fifo->max       = size;
   52   1          return FIFO_SUCCESS;
C251 COMPILER V5.60.0,  zf_fifo                                                            06/07/24  23:05:05  PAGE 2   

   53   1      }
   54          
   55          //-------------------------------------------------------------------------------------------------------
             -------------
   56          // @brief       FIFO 头指针位移
   57          // @param       *fifo           FIFO 对象指针
   58          // @param       offset          偏移量
   59          // @return      void
   60          // Sample usage:
   61          //-------------------------------------------------------------------------------------------------------
             -------------
   62          void fifo_head_offset (fifo_struct *fifo, uint32 offset)
   63          {
   64   1          fifo->head += offset;
   65   1      
   66   1          while(fifo->max <= fifo->head)                                              // 如果范围超过则减缓冲区
             -大小 直到小于最大缓冲区大小
   67   1          {
   68   2              fifo->head -= fifo->max;
   69   2          }
   70   1      }
   71          
   72          //-------------------------------------------------------------------------------------------------------
             -------------
   73          // @brief       FIFO 尾指针位移
   74          // @param       *fifo           FIFO 对象指针
   75          // @param       offset          偏移量
   76          // @return      void
   77          // Sample usage:
   78          //-------------------------------------------------------------------------------------------------------
             -------------
   79          void fifo_end_offset (fifo_struct *fifo, uint32 offset)
   80          {
   81   1          fifo->end += offset;
   82   1      
   83   1          while(fifo->max <= fifo->end)                                               // 如果范围超过则减缓冲区
             -大小 直到小于最大缓冲区大小
   84   1          {
   85   2              fifo->end -= fifo->max;
   86   2          }
   87   1      }
   88          
   89          //-------------------------------------------------------------------------------------------------------
             -------------
   90          // @brief       FIFO 重置缓冲器
   91          // @param       *fifo           FIFO 对象指针
   92          // @return      void
   93          // Sample usage:
   94          //-------------------------------------------------------------------------------------------------------
             -------------
   95          void fifo_clear (fifo_struct *fifo)
   96          {
   97   1          fifo->head      = 0;
   98   1          fifo->end       = 0;
   99   1          fifo->size      = fifo->max;
  100   1      }
  101          
  102          //-------------------------------------------------------------------------------------------------------
             -------------
  103          // @brief       FIFO 查询当前数据个数
  104          // @param       *fifo           FIFO 对象指针
  105          // @return      void
  106          // Sample usage:
  107          //-------------------------------------------------------------------------------------------------------
             -------------
  108          uint32 fifo_used (fifo_struct *fifo)
C251 COMPILER V5.60.0,  zf_fifo                                                            06/07/24  23:05:05  PAGE 3   

  109          {
  110   1          return (fifo->max - fifo->size);
  111   1      }
  112          
  113          //-------------------------------------------------------------------------------------------------------
             -------------
  114          // @brief       向 FIFO 中写入数据
  115          // @param       *fifo           FIFO 对象指针
  116          // @param       *dat            数据来源缓冲区指针
  117          // @param       length          需要写入的数据长度
  118          // @return      fifo_state_enum 操作状态
  119          // Sample usage:                if(fifo_write_buffer(&fifo,data,32)!=FIFO_SUCCESS) while(1);
  120          //-------------------------------------------------------------------------------------------------------
             -------------
  121          fifo_state_enum fifo_write_buffer (fifo_struct *fifo, uint8 *dat, uint32 length)
  122          {
  123   1          uint32 temp_length;
  124   1      
  125   1          if(length < fifo->size)                                                     // 剩余空间足够装下本次数
             -据
  126   1          {
  127   2              temp_length = fifo->max - fifo->head;                                   // 计算头指针距离缓冲区尾
             -还有多少空间
  128   2      
  129   2              if(length > temp_length)                                                // 距离缓冲区尾长度不足写
             -入数据 环形缓冲区分段操作
  130   2              {
  131   3                  memcpy(&fifo->buffer[fifo->head], dat, (uint16)temp_length);                // 拷贝第一段数据
  132   3                  fifo_head_offset(fifo, temp_length);                                // 头指针偏移
  133   3                  dat += temp_length;                                                 // 读取缓冲偏移
  134   3                  memcpy(&fifo->buffer[fifo->head], dat, length - temp_length);       // 拷贝第一段数据
  135   3                  fifo_head_offset(fifo, length - temp_length);                       // 头指针偏移
  136   3              }
  137   2              else
  138   2              {
  139   3                  memcpy(&fifo->buffer[fifo->head], dat, (uint16)length);                     // 一次完整写入
  140   3                  fifo_head_offset(fifo, length);                                     // 头指针偏移
  141   3              }
  142   2      
  143   2              fifo->size -= length;                                                   // 缓冲区剩余长度减小
  144   2          }
  145   1          else
  146   1          {
  147   2              return FIFO_SPACE_NO_ENOUGH;
  148   2          }
  149   1      
  150   1          return FIFO_SUCCESS;
  151   1      }
  152          
  153          //-------------------------------------------------------------------------------------------------------
             -------------
  154          // @brief       从 FIFO 读取数据
  155          // @param       *fifo           FIFO 对象指针
  156          // @param       *dat            目标缓冲区指针
  157          // @param       *length         读取的数据长度 如果没有这么多数据这里会被修改
  158          // @param       flag            是否变更 FIFO 状态 可选择是否清空读取的数据
  159          // @return      fifo_state_enum 操作状态
  160          // Sample usage:                if(fifo_read_buffer(&fifo,data,32,FIFO_READ_ONLY)!=FIFO_SUCCESS) while(1)
             -;
  161          //-------------------------------------------------------------------------------------------------------
             -------------
  162          fifo_state_enum fifo_read_buffer (fifo_struct *fifo, uint8 *dat, uint32 *length, fifo_operation_enum flag
             -)
  163          {
  164   1          uint8 data_check = 0;
  165   1          uint32 temp_length;
C251 COMPILER V5.60.0,  zf_fifo                                                            06/07/24  23:05:05  PAGE 4   

  166   1      
  167   1          if(*length > fifo_used(fifo))
  168   1          {
  169   2              *length = (fifo->max - fifo->size);                                     // 纠正读取的长度
  170   2              data_check = 1;                                                         // 标志数据不够
  171   2          }
  172   1      
  173   1          temp_length = fifo->max - fifo->end;                                        // 计算尾指针距离缓冲区尾
             -还有多少空间
  174   1      
  175   1          if(*length <= temp_length)                                                  // 足够一次性读取完毕
  176   1          {
  177   2              if(NULL != dat)    memcpy(dat, &fifo->buffer[fifo->end], (uint16) * length);    // 一次性读取完毕
  178   2          }
  179   1          else
  180   1          {
  181   2              if(NULL != dat)
  182   2              {
  183   3                  memcpy(dat, &fifo->buffer[fifo->end], (uint16)temp_length);                 // 拷贝第一段数据
  184   3                  memcpy(&dat[temp_length], &fifo->buffer[0], *length - temp_length); // 拷贝第二段数据
  185   3              }
  186   2          }
  187   1      
  188   1          if(flag == FIFO_READ_AND_CLEAN)                                             // 如果选择读取并更改 FIF
             -O 状态
  189   1          {
  190   2              fifo_end_offset(fifo, *length);                                         // 移动 FIFO 头指针
  191   2              fifo->size += *length;
  192   2          }
  193   1      
  194   1          return (data_check ? FIFO_DATA_NO_ENOUGH : FIFO_SUCCESS);
  195   1      }
  196          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1131     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        71     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
